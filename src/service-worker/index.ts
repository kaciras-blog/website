/// <reference path="./serviceworker.d.ts" />
import { cacheNames, CacheProxyServer, ManagedCache, RegexRoute } from "./cache";

// This field will be generated by ServiceWorkerWebpackPlugin.
declare var serviceWorkerOption: {
	assets: string[];
};

// self.addEventListener("error", function (e) {
// 	self.clients.matchAll().then(clients => {
// 		if (clients && clients.length) {
// 			clients[0].postMessage({
// 				type: "ERROR",
// 				msg: e.message || null,
// 				stack: e.error ? e.error.stack : null,
// 			});
// 		}
// 	});
// });
//
// self.addEventListener("unhandledrejection", function (e) {
// 	self.clients.matchAll().then(clients => {
// 		if (clients && clients.length) {
// 			clients[0].postMessage({
// 				type: "REJECTION",
// 				msg: e.reason ? e.reason.message : null,
// 				stack: e.reason ? e.reason.stack : null,
// 			});
// 		}
// 	});
// });

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
								主要逻辑部分
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

const STATIC_CACHE_NAME = "StaticFiles";
const proxyServer = new CacheProxyServer();

const staticCache = new ManagedCache(STATIC_CACHE_NAME); // add STATIC_CACHE_NAME to cacheNames
proxyServer.addRoute(new RegexRoute("/static/", staticCache.cacheFirst()));
proxyServer.addRoute(new RegexRoute("/$", staticCache.networkFirst()));

// const ApiCache = new ManagedCache("API", 256, 7 * 24 * 60 * 60);
// proxyServer.addRoute(new RegexRoute("//api.kaciras.net/", ApiCache.staleWhileRevalidate()));

self.addEventListener("install", (event: InstallEvent) => {
	const { assets } = serviceWorkerOption;
	assets.push("/?shellOnly=true");

	event.waitUntil(caches.open(STATIC_CACHE_NAME)
		.then(cache => cache.addAll(assets))
		.then(() => console.log("Precache successfully."))
		.catch(err => console.error("Precache failure.", err))
	);
	return skipWaiting();
});

self.addEventListener("activate", (event: ActivateEvent) => {
	console.log("[ServiceWorker]: Activate!");

	// 删除当前版本用不到的缓存，并启用导航预载
	const init = async () => {
		const keys = (await caches.keys()).filter(k => !cacheNames.has(k));
		await Promise.all(keys.map(k => caches.delete(k)));

		if (registration.navigationPreload) {
			await registration.navigationPreload.enable();
		}
	};

	event.waitUntil(init());
	return clients.claim();
});

self.addEventListener("fetch", proxyServer.fetchHandler());
