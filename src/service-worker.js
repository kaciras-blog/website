const cacheNames = new Set();


class ManagedCache {

	constructor (name, maxSize = null) {
		if (cacheNames.has(name)) {
			throw new Error(`ManagedCache ${name} already exists.`);
		}
		cacheNames.add(name);

		this.name = name;
		this.maxSize = maxSize;
	}

	put (request, response) {
		response = response.clone();
		return caches.open(this.name).then(cache => cache.put(request, response));
	}

	networkFirst () {
		return new NetworkFirstHandler(this);
	}

	cacheFirst () {
		return new CacheFirstHandler(this);
	}

	staleWhileRevalidate () {
		return new StaleWhileRevalidateHandler(this);
	}
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
									缓存策略
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

class AbstractFetchHandler {

	constructor (cache) {
		this.cache = cache;
	}

	async fetchAndCache (request) {
		const response = await fetch(request, { cache: "no-store" });
		if (response.status >= 200 && response.status < 400) {
			this.cache.put(request, response);
		}
		return response;
	}
}

/**
 * 网络优先，适用于频繁更新但又需要离线访问的内容。
 */
class NetworkFirstHandler extends AbstractFetchHandler {

	async handle (request) {
		try {
			return await this.fetchAndCache(request);
		} catch (err) {
			const cached = await caches.match(request);
			if (cached) {
				return cached;
			}
			throw err;
		}
	}
}

/**
 * 缓存优先，并在后台更新。
 */
class StaleWhileRevalidateHandler extends AbstractFetchHandler {

	async handle (request) {
		const cached = await caches.match(request);
		if (cached) {
			this.fetchAndCache(request);
			return cached;
		}
		return await this.fetchAndCache(request);
	}
}

/**
 * 缓存优先。尝试从缓存里加载响应，如果缓存中没有则发送请求，并将成功的响应加入缓存。
 * 该策略适用于文件名中带 Hash 的请求。
 */
class CacheFirstHandler extends AbstractFetchHandler {

	async handle (request) {
		// 如果请求的资源已被缓存，则直接返回
		const cached = await caches.match(request);
		if (cached) {
			return cached;
		}
		// 没有，则发起请求并缓存结果
		return await this.fetchAndCache(request);
	}
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
									请求拦截
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

class CacheProxyServer {

	constructor () {
		this.routes = [];
	}

	addRoute (pattern, handler) {
		this.routes.push({ pattern, handler });
		return this;
	}

	handleFetchEvent (event) {
		const { request } = event;

		if (request.method !== "GET") {
			return;
		}
		const url = new URL(request.url);

		let matchedRoute;
		for (const route of this.routes) {
			if (route.pattern.test(url.pathname)) {
				matchedRoute = route;
				break;
			}
		}

		if (matchedRoute) {
			event.respondWith(matchedRoute.handler.handle(request));
		}
	}

	fetchHandler () {
		return event => this.handleFetchEvent(event);
	}
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
								 业务逻辑部分
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

const STATIC_CACHE_NAME = "StaticFiles-V1";

const proxyServer = new CacheProxyServer();
const staticCache = new ManagedCache(STATIC_CACHE_NAME); // add STATIC_CACHE_NAME to cacheNames
proxyServer.addRoute(new RegExp("^/static/"), staticCache.cacheFirst());


self.addEventListener("install", event => {
	// This field will be generated by ServiceWorkerWebpackPlugin.
	// noinspection JSUnresolvedVariable
	const { assets } = global.serviceWorkerOption;

	event.waitUntil(caches.open(STATIC_CACHE_NAME)
		.then(cache => cache.addAll(assets))
		.then(() => console.log("Precache successfully."))
		.catch(err => console.error("Precache failure.", err))
	);
	return self.skipWaiting();
});

self.addEventListener("activate", event => {
	console.log("[ServiceWorker]: Activate");

	// 删除当前版本用不到的缓存
	event.waitUntil(caches.keys().then(keys =>
		Promise.all(keys.filter(k => !cacheNames.has(k)).map(k => caches.delete(k)))));

	return self.clients.claim();
});

self.addEventListener("fetch", proxyServer.fetchHandler());
